;; Copyright 2020 Google LLC
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;  https://www.apache.org/licenses/LICENSE-2.0
;;
;;  Unless required by applicable law or agreed to in writing, software
;;  distributed under the License is distributed on an "AS IS" BASIS,
;;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;  See the License for the specific language governing permissions and
;;  limitations under the License.

(doc Traversals "
  Defines traversals and reductions over lists by decomposing them into
  products using a consumer function (see `Consumers`) and applying a binary
  function.

  Use traversals to define generic folds over lists of values.

  Many traversals converge toward idempotency once an input list is exhausted,
  thus, even if the limit of a generic fold exceeds the length of an input list,
  the result remains the same. Not all traversals have this property.")
(defmodule Traversals
  ;; two functions; f which describes how to process r; t which describes how
  ;; to consume/traverse r in terms of products that delimit structure. If
  (doc traverse "
    Defines a traversal over a cons-like structure.

    `traverse` takes two functions as input `f` and `t`, each of which should
    satisfy the following rules in order to produce a 'well-behaved' traversal:

    - `f` should be a *monoidal* operation over the left component produced by
      `t`
    - `t` should be a consumer (see `Consumers`) that deconstructs an input
      list into a product. `traverse` will pass the left component of the
      product to `f` and use the right component as input to the next recursion.
    ")
  (defndynamic traverse [f t]
    (fn [s r]
        (if (empty? r)
            (Folders.Product.product s r)
            (Folders.Product.map-l (curry f s) (t r)))))

  (doc combine
    "A traversal that combines a list of values one-by-one using the monoidal operation `m`.

    This traversal becomes idempotent after the input list is exhausted.

    ```
    (fold (combine +) 0 '(1 2 3 4) 4)
    => 10
    (fold (combine +) 0 '(1 2 3 4) 1000)
    => 10
    ```")
  (defndynamic combine [m] (Folders.Traversals.traverse m Folders.Consumers.each))

  (doc cycle "
    A traversal that appends the contents of an input list to itself.

    ```
    (fold cycle '() '(1 2 3 4) 3)
    => (1 2 3 4 1 2 3 4 1 2 3 4)
    ```")
  (defdynamic cycle (Folders.Traversals.traverse append Folders.Consumers.id))

  (doc suffixes
    "A traversal that maps elements of an input list to their tails.

    This traversal becomes idempotent after the input list is exhausted.

    ```
    (fold suffixes '() '(1 2 3 4) 4)
    => ((2 3 4) (3 4) (4) ())
    (fold suffixes '() '(1 2 3 4) 4000)
    => ((2 3 4) (3 4) (4) ())
    ```")
  (defdynamic suffixes (Folders.Traversals.traverse (Folders.Consumers.lift-r append) Folders.Consumers.tails))

  (doc index "
    A traversal that returns the element of an input list at a given index.

    This traversal becomes idempotent after the input list is exhausted.

    ```
    (fold index 0 '(5 6 7 8) 2)
    => 6
    ```")
  (defdynamic index
    (Folders.Traversals.traverse
      (compose Folders.Product.right Folders.Product.product)
      Folders.Consumers.each))

  (doc concat "
    A traversal that concatenates a list of lists.

    This traversal becomes idempotent after the input list is exhuasted.

    ```
    (fold concat '() '((5 6 7) (8 9 10)) 2)
    => (5 6 7 8 9 10)
    (fold concat '() '((5 6 7) (8 9 10)) 200)
    => (5 6 7 8 9 10)
    ```")
  (defdynamic concat (Folders.Traversals.traverse append Folders.Consumers.each))

  (doc filter "
    A traversal that filters elements from the input list that do not satisfy `p`.

    This traversal becomes idempotent after the input list is exhausted.

    ```
    (fold (filter (fn [x] (= 2 x))) '() '(1 2 2 3 4) 5)
    => (2 2)
    (fold (filter (fn [x] (= 2 x))) '() '(1 2 2 3 4) 500)
    => (2 2)
    ```")
  (defndynamic filter [p]
    (Folders.Traversals.traverse (Folders.Recursions.filter p) Folders.Consumers.each))
)
